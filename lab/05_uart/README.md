# USART
**USART** (Universal Synchronous-Asynchronous Receiver/Transmitter) — универсальный синхронно-асинхронный приёмопередатчик, интерфейс для передачи данных между цифровыми устройствами. Он на столько универсальный, что даже провода по которым к вам домой приходит интернет, это тоже USART (RS485).

В нашем итоговом проекте USART понадобится нам для передачи денных от блока управления ракеты на наш компьютер. Забегая вперед общение с радиомодулем hc-12 осуществляется с помощью интерфейса USART.

USART микроконтроллера stm32 может работать в различных режимах — асинхронный, синхронный, полудуплекс и т.д.

Рассмотрим по подробнее асинхронный режим (UART)

## Asynchronous

![Asynchronous](./image/asynchronous.jpg)

Интерфейс UART использует два провода для передачи данных: один для отправки (TX) и один для приема (RX). Он работает в асинхронном режиме, что означает, что данные передаются без использования внутреннего тактового сигнала. 

На каждом модуле использующем интерфейс UART есть пины подписаные надписями TXD и RXD. Соединяя пины микроконтроллера настроенные на передачу данных по интерфейсу UART с пинами на модуле UART (USB_to_TTL или HC-12), пины TXD и RXD модуля должны быть подключены к Rx и Tx пинам микроконтроллера соответсвенно. T-transmit(пердавать) R-receive(принимать) когда один модуль передает данные, он как бы дергает провод своим выходом Transmit, принимающий же модуль улавливает эти импульсы своим входом Receive.

RX **<>** TX

TX **<>** RX

### Пакет данных
Данные передаются по проводам, на которых может быть либо положительное напряжение питания 3V3 (или HIGH - высокое состояние) либо земля GND (или LOW - низкое состояние). Поэтому все передающиеся данные представленны в двоичной системе исчисления, то есть это нули и еденицы. Нуль или еденица называется одим битом информации. Наши данные это и есть последовательность бит (нулей и едениц), физически это установдение 3V3 или GND на проводах TX или RX. 
Когда устройство отправляет данные, оно посылает каждый байт (8 бит) последовательно, начиная со стартого бита, далее биты данных, бит четности (если он используется), и наконец, стоп-бит. Приемное устройство считывает эти биты в правильной последовательности и принимает переданные данные.

![Пакет данных](./image/bit_packet.jpg)


### Старт- и Стоп-биты 

Передача каждого байта начинается со старт-бита, который устанавливается в логическую "0", чтобы указать начало передачи. Затем идут данные, после которых следуют биты четности (если они используются), и наконец, один или несколько стоп-битов, которые устанавливаются в логическую "1" и указывают конец передачи.

### Пример

Представим, что мы отправляем байт данных "01001011". Последовательность будет выглядеть так:
- Старт-бит: 0
- Данные: 01001011
- Бит четности (если используется)
- Стоп-бит: 1

Это позволяет приемнику правильно интерпретировать переданные данные.

## Настройки UART в CubeIde


Тут следует немного пояснить работу USART'а для упрощения понимания некоторых настроек.

Мы будем передавать 8-ми битные байты (в отдельных случаях байты могут 9-ти битные), на скорости 115200 бит в секунду…

![настройки](./image/settings.jpg)

- **Baud Rate** — скорость передачи (должна совпадать на обоих устройствах общения).
- **Word Length** — длинаа данных в педеющемся пакете.
- **Parity** — использование бита проверки чётности (см. ниже).
- **Stop Bits** — количество стоповых битов (1 или 2).
- **Data Direction** — включается приём и передача, или что-то одно.
- **Over Sampling** — см. ниже.

Получаемый пакет из восьми бит (один байт) выглядит так…

![Пакет данных](./image/bit_packet.jpg)

Отправляемые/получаемые байты отделяются друг от друга стартовыми и стоповыми битами.

Если ничего не передаётся, то линия находится в состоянии HIGH. Передатчик, начиная отправку, прижимает линию к «земле», а приёмник расценивает это как начало пакета — START (стартовый бит). Далее идёт приём (отсчитывая биты) и после последнего (D7) бита проверяется что линия установлена в HIGH — STOP (стоповый бит). Иногда для большей достоверности окончания приёма используются два стоповых бита.


Количество принятых бит подсчитывается следующим образом: как только появляется стартовый бит (переход с HIGH на LOW) сразу же начинается отсчёт — 16 тиков на каждый бит… (количество тиков это и есть **Over Sampling**)



**Parity** — бит чётности. С помощью этого бита можно проверять целостность полученного пакета.

Пакет с добавленным битом чётности выглядит так…


Word Length нужно указать 9 Bits. Если оставить 8 Bits, то полезных битов будет 7.

При отправке в этот бит записывается единица или ноль в зависимости от количества единичек в предыдущих восьми битах. Если единичек чётное кол-во, то записывается 0, если нечётное, то 1.

То есть:

Если отправляется 10111101 (шесть единичек — чётное количество), то бит чётности будет 0. Пакет будет выглядеть так — 101111010.

Если отправляется 01110011 (пять единичек — нечётное количество), то бит чётности будет 1. Пакет будет выглядеть так — 011100111.

При приёме такого пакета производится проверка — соответствует ли количество единичек значению в девятом бите, и если не соответствует, то пакет считается повреждённым — ошибка контроля чётности (HAL_UART_ERROR_PE).

Вычисления производятся с помощью битовой операции XOR (исключающее «или»).

Проверка конечно так себе. Теоретически может одна единичка превратится в ноль, а другой ноль в единичку, и тогда проверка ничего не выявит.

## Элементы кода 

> [!NOTE]
> Чтобы принять или отправить данные достаточно описанных выше настроек.


Отправить строку «Hello World» можно так:

>HAL_UART_Transmit(&huart1, (uint8_t*)"Hello World\n", 12, 1000);

- Первый аргумент — указатель на структуру USART
- Второй аргумент — строка (приведённая к указателю)
- Третий кол-во символов в отправляемой строке
- Четвёртый — таймаут в миллисекундах (если по каким-то причинам не удастся выполнить отправку в течении секунды, то вернётся ошибка).

Эта функция блокирующая, то есть пока она не выполнится программа будет приостановлена.


Чтоб не блокировать программу на время отправки, нужно воспользоваться функцией с прерыванием по завершению передачи.

Включите глобальное прерывание…

![Interrupt](./image/interrupt.jpg)

Отправлять данные так:

>HAL_UART_Transmit_IT(&huart1, (uint8_t*)"Hello World\n", 12);

Здесь нет таймаута так как нам ничего не нужно ждать — отправили и забыли. Остальные аргументы те же, что и у блокирующей функции.

По окончании отправки сработает прерывание и вызовет колбек:
```
void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
{
          if(huart == &huart1)
          {
                  // можно установить какой-то флаг, сообщающий об окончании отправки
          }     
}
```

Отправить массив:
```
/* USER CODE BEGIN Includes */
#include "string.h"
/* USER CODE END Includes */
...

char buff[16] = {0,};

snprintf(buff, 15, "Hello World\n");
HAL_UART_Transmit_IT(&huart1, (uint8_t*)buff, strlen(buff));
```
Второй аргумент — указатель на массив, третий — длина строки в массиве.
